# 質問３

## 上記の単体テストを書くためには、依存性の注入とモック化を行う必要がありました
## そもそも、なぜ元の関数はカバレッジ100%のテストを書けなかったのでしょうか？

元のnameApiServiceやDatabaseMockは、返ってくる値にランダム性があった。
DatabaseMockではランダムで失敗することがある、
nameApiServiceでは結果で返ってくる名前がランダムな状態のため、予測される結果が想定できない状態でした。


## 依存性の注入とは何でしょうか？どのような問題を解決するために使われるのでしょうか？

ある関数Aの中で、外部のクラスBのインスタンスを利用している場合、
そのBクラスのインスタンスの持つメソッドや値に頼っていると、
その外部Bクラスの仕組みに依存してしまう。

例えば外部Bクラスのexampleメソッドが10しか返さないメソッドとする。
10を返すことを前提にAを組み立ててしまうと、Bクラスの変更をした際に関数Aにも影響が出てしまう。
そのため、Aで使うBクラスのインスタンスを、インターフェースなどで外部から注入すること。


## 依存性の注入を実施することで、モジュール同士の結合度の強さはどのように変化したでしょうか？

結合度は弱まります。

## 単体テストで外部サービスとの通信が発生すると、どのようなデメリットがあるでしょうか？

・外部サービスがトラブルでダウンした場合などに値が取れない
・外部サービスや外部関数の仕様が変わった際に、予期している値が取れない
など、テストする関数のみで結果を意識、管理できないというデメリットがあります。




https://jestjs.io/ja/docs/mock-functions#%E3%83%A2%E3%83%83%E3%82%AF%E3%81%AE%E6%88%BB%E3%82%8A%E5%80%A4
mock関数は、テスト中のコードにテスト用の値を注入するのにも利用できます。